package kafka

import (
	"fmt"
	"testing"

	"github.com/xdg-go/scram"
)

// TestSCRAMMessageFormat examines the exact format of SCRAM messages generated by xdg-go/scram
func TestSCRAMMessageFormat(t *testing.T) {
	username := "scramuser"
	password := "scrampass"

	// Generate server credentials
	serverCreds, err := generateSCRAMCredentials("SCRAM-SHA-256", username, password)
	if err != nil {
		t.Fatalf("Failed to generate credentials: %v", err)
	}

	// Create credential lookup
	credLookup := func(user string) (scram.StoredCredentials, error) {
		if user == username {
			return serverCreds, nil
		}
		return scram.StoredCredentials{}, fmt.Errorf("user not found")
	}

	// Create server
	server, err := scram.SHA256.NewServer(credLookup)
	if err != nil {
		t.Fatalf("Failed to create server: %v", err)
	}

	// Create client (using franz-go compatible client)
	client, err := scram.SHA256.NewClient(username, password, "")
	if err != nil {
		t.Fatalf("Failed to create client: %v", err)
	}

	// Start conversations
	serverConv := server.NewConversation()
	clientConv := client.NewConversation()

	// Step 1: Client first message
	clientFirst, err := clientConv.Step("")
	if err != nil {
		t.Fatalf("Client first step failed: %v", err)
	}
	t.Logf("Client first (len=%d):", len(clientFirst))
	t.Logf("  Text: %s", clientFirst)
	t.Logf("  Hex:  %x", []byte(clientFirst))

	// Step 2: Server first message
	serverFirst, err := serverConv.Step(clientFirst)
	if err != nil {
		t.Fatalf("Server first step failed: %v", err)
	}
	t.Logf("\nServer first (len=%d):", len(serverFirst))
	t.Logf("  Text: %s", serverFirst)
	t.Logf("  Hex:  %x", []byte(serverFirst))

	// Analyze server first message byte by byte around position 44
	if len(serverFirst) > 44 {
		t.Logf("\nBytes around position 44:")
		for i := 40; i < len(serverFirst) && i < 55; i++ {
			ch := serverFirst[i]
			t.Logf("  [%d]: 0x%02x '%c' (printable: %v)", i, ch, ch, ch >= 32 && ch <= 126)
		}
	}

	// Step 3: Client final message
	clientFinal, err := clientConv.Step(serverFirst)
	if err != nil {
		t.Fatalf("Client final step failed: %v", err)
	}
	t.Logf("\nClient final (len=%d):", len(clientFinal))
	t.Logf("  Text: %s", clientFinal)
	t.Logf("  Hex:  %x", []byte(clientFinal))

	// Step 4: Server final message
	serverFinal, err := serverConv.Step(clientFinal)
	if err != nil {
		t.Fatalf("Server final step failed: %v", err)
	}
	t.Logf("\nServer final (len=%d):", len(serverFinal))
	t.Logf("  Text: %s", serverFinal)
	t.Logf("  Hex:  %x", []byte(serverFinal))

	// Analyze server final message byte by byte
	if len(serverFinal) > 44 {
		t.Logf("\nBytes around position 44 in server-final:")
		for i := 40; i < len(serverFinal) && i < 55; i++ {
			ch := serverFinal[i]
			t.Logf("  [%d]: 0x%02x '%c' (printable: %v)", i, ch, ch, ch >= 32 && ch <= 126)
		}
	}

	// Verify conversation completed
	_, err = clientConv.Step(serverFinal)
	if err != nil {
		t.Fatalf("Client verification failed: %v", err)
	}

	if !serverConv.Done() || !serverConv.Valid() {
		t.Fatal("Server conversation not done or invalid")
	}
	if !clientConv.Done() || !clientConv.Valid() {
		t.Fatal("Client conversation not done or invalid")
	}

	t.Log("\nSCRAM handshake completed successfully with xdg-go/scram client!")
}
